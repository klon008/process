// Generated by CoffeeScript 1.12.7
(function() {
  var TStateProcessor, all_processes_stack, createProcessTab, draw_process, erase_process, generateHTMLbyProcess, generatePlainbyProcess, generateSelectTags, handleFileSelect, img_cats, io, ioRedraw, ioTimer, iorange, lastStartedTimer, listener, mConsole, mMemory, mMemoryCell, openTab, paintCat, process, processTimer, processTimerRunned, process_comands, process_context, process_descriptor, process_priors, process_states, processes_dispatcher, processor, processorStartButton, ready_processes_stack, redraw_process, split_command, switchTimer, tick, timerRunned, waiting_processes_stack,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
    alert('Браузер не поддерживает чтение файлов!!!!');
  }

  mConsole = (function() {
    function mConsole() {}

    mConsole.t = document.getElementById('console');

    mConsole.log = function(inText) {
      if (typeof inText === 'string') {
        return mConsole.t.innerHTML += "<div>" + inText + "</div>";
      } else {
        throw inText + " не является текстом";
      }
    };

    return mConsole;

  })();

  tippy(".spooling_element");

  process_priors = Object.freeze({
    Highest: "Очень высокий",
    High: "Высокий",
    Normal: "Нормальный",
    Low: "Низкий",
    Lowest: "Очень низкий"
  });

  process_states = Object.freeze({
    None: "Нет состояния",
    Run: "Выполнение",
    Ready: "Готовность",
    Wait: "Ожидание",
    Finish: "Завершился"
  });

  TStateProcessor = Object.freeze({
    Empty: "Empty",
    Busy: "Busy"
  });

  process_comands = Object.freeze({
    NONE: "NONE",
    MEMORY: "ПАМЯТЬ",
    PROCESSOR: "ПРОЦЕССОР",
    IO: "ВВОД\\ВЫВОД",
    end: "КОНЕЦ"
  });

  img_cats = ["1.jfif", "2.jpg", "3.jfif", "4.jfif", "5.png", "6.png", "7.jfif", "8.png"];

  ready_processes_stack = [];

  waiting_processes_stack = [];

  all_processes_stack = [];

  mMemoryCell = (function() {
    function mMemoryCell(busy, pid1, name, memory, htmlLinks, process1, start_byte, end_byte) {
      this.busy = busy != null ? busy : false;
      this.pid = pid1 != null ? pid1 : null;
      this.name = name != null ? name : null;
      this.memory = memory != null ? memory : null;
      this.htmlLinks = htmlLinks != null ? htmlLinks : null;
      this.process = process1 != null ? process1 : null;
      this.start_byte = start_byte != null ? start_byte : null;
      this.end_byte = end_byte != null ? end_byte : null;
      return this;
    }

    mMemoryCell.prototype.draw_mem = function() {
      var memoryTable, tr;
      memoryTable = document.querySelector("#memory_table");
      tr = document.createElement("div");
      tr.setAttribute('data-id', this.pid);
      tr.setAttribute('data-mem_used', this.memory);
      tr.innerHTML = "<b>" + this.pid + "</b>";
      tr.classList.add("blocked");
      tr.style.width = 100 * this.memory / mMemory.MAX + "%";
      tr.style.left = 100 * this.start_byte / mMemory.MAX + "%";
      memoryTable.append(tr);
      return this.htmlLinks = tr;
    };

    return mMemoryCell;

  })();

  mMemory = (function() {
    function mMemory() {}

    mMemory.FREE = 65535;

    mMemory.MAX = 65535;

    mMemory.memory_sections = [];

    mMemory.use = function(process, mem) {
      var busy_elems, cell, i_mem, j, k, len, min;
      if (this.FREE > mem) {
        if (true) {
          cell = new mMemoryCell(true, process.descriptor.pid, process.descriptor.FileName, mem, null, process, null, null);
          if (this.memory_sections.length === 0) {
            cell.start_byte = 0;
            cell.end_byte = cell.start_byte + mem;
            cell.draw_mem();
            this.FREE = this.FREE - cell.memory;
            this.memory_sections.push(cell);
            process.context.memory = mem;
            mConsole.log("Процесс <span class='proc_name'>" + process.descriptor.FileName + "</span> <b>(" + process.descriptor.pid + ")</b> Занял <b>" + cell.memory + "</b> Памяти!");
          } else {
            i_mem = 0;
            while (i_mem <= this.MAX) {
              busy_elems = this.memory_sections.filter(function(x) {
                var end;
                end = i_mem + mem;
                return (i_mem >= x.start_byte && i_mem <= x.end_byte) || (end >= x.start_byte && end <= x.end_byte) || (i_mem <= x.start_byte && x.end_byte <= end);
              });
              if (busy_elems.length === 0) {
                cell.start_byte = i_mem;
                cell.end_byte = i_mem + mem;
                cell.draw_mem();
                this.FREE = this.FREE - cell.memory;
                this.memory_sections.push(cell);
                process.context.memory = mem;
                mConsole.log("Процесс <span class='proc_name'>" + process.descriptor.FileName + "</span> <b>(" + process.descriptor.pid + ")</b> Занял <b>" + cell.memory + "</b> Памяти!");
                break;
              } else {
                min = busy_elems[busy_elems.length - 1].end_byte;
                for (k = 0, len = busy_elems.length; k < len; k++) {
                  j = busy_elems[k];
                  if (min > j.end_byte) {
                    min = j.end_byte;
                  }
                }
                i_mem = min + 1;
              }
              if ((i_mem + mem) >= this.MAX) {
                alert("НЕДОСТАТОЧНО ПАМЯТИ");
                throw "НЕДОСТАТОЧНО ПАМЯТИ";
                break;
              }
            }
            this.refresh();
          }
          return true;
        } else {
          this.refresh();
          return true;
        }
      } else {
        alert("НЕДОСТАТОЧНО ПАМЯТИ");
        throw "НЕДОСТАТОЧНО ПАМЯТИ";
        return false;
      }
    };

    mMemory.refresh = function() {
      return document.getElementById('memory_free').innerText = this.FREE + " / " + this.MAX;
    };

    mMemory.free = function(process) {
      var i, n;
      n = 0;
      while (n <= this.memory_sections.length - 1) {
        i = this.memory_sections[n];
        if (i.pid === process.descriptor.pid) {
          this.memory_sections[n].htmlLinks.remove();
          this.memory_sections.splice(n, 1);
          mConsole.log("Процесс <span class='proc_name'>" + process.descriptor.FileName + "</span> <b>(" + process.descriptor.pid + ")</b> Осовободил <b>" + process.context.memory + "</b> Памяти!");
          this.FREE = this.FREE + process.context.memory;
          this.refresh();
          return;
        } else {
          n++;
        }
      }
    };

    return mMemory;

  })();

  process = (function() {
    function process(descriptor, context1) {
      this.descriptor = descriptor;
      this.context = context1;
      if ((this.descriptor instanceof process_descriptor) && (this.context instanceof process_context)) {

      } else {
        throw "Контексти или дескриптор не верны!";
      }
    }

    process.prototype.refreshCommand = function() {
      var command, line_index;
      line_index = this.context.CommandLine;
      command = this.descriptor.command_list[line_index];
      if (command) {
        command = split_command(command);
        return this.context.Command = command.command_type;
      }
    };

    return process;

  })();

  process_descriptor = (function() {
    process_descriptor.pid = 0;

    function process_descriptor(pid1, quantum, State, priority, command_list1, FileName1, Waiting) {
      this.pid = pid1;
      this.quantum = quantum != null ? quantum : 0;
      this.State = State != null ? State : process_states.None;
      this.priority = priority != null ? priority : process_priors.Normal;
      this.command_list = command_list1 != null ? command_list1 : command_list;
      this.FileName = FileName1 != null ? FileName1 : FileName;
      this.Waiting = Waiting != null ? Waiting : null;
      this.pid = process_descriptor.pid++;
    }

    return process_descriptor;

  })();

  process_context = (function() {
    function process_context(pid1) {
      this.pid = pid1;
      this.pid;
      this.CommandLine = 0;
      this.Command = "cNONE";
      this.CommandValue = 0;
      this.CurrentRun = 0;
      this.memory = 0;
    }

    return process_context;

  })();

  processor = (function() {
    function processor() {}

    processor.current_process;

    processor.TStateProcessor = TStateProcessor.Empty;

    processor.run = function(runned_process) {

      /*if (runned_process instanceof process) */
      var processIndexInRunned;
      processor.current_process = runned_process;
      processor.TStateProcessor = TStateProcessor.Busy;
      document.getElementById("processor_state").innerHTML = "Занят";
      document.getElementById("processor_cur_process").innerHTML = runned_process.descriptor.FileName;
      runned_process.descriptor.State = process_states.Run;
      processIndexInRunned = ready_processes_stack.indexOf(runned_process);
      ready_processes_stack.splice(processIndexInRunned, 1);
      return this;
    };

    processor.finishCurProc = function() {
      processor.TStateProcessor = TStateProcessor.Empty;
      document.getElementById("processor_state").innerHTML = processor.TStateProcessor;
      return document.getElementById("processor_cur_process").innerHTML = "-";
    };

    processor.clearProcessor = function() {
      this.TStateProcessor = TStateProcessor.Empty;
      document.getElementById("processor_state").innerHTML = processor.TStateProcessor;
      document.getElementById("processor_cur_process").innerHTML = "-";
      return this.current_process = null;
    };

    processor.moveProcessToReady = function() {
      processor.current_process.descriptor.State = process_states.Ready;
      ready_processes_stack.push(processor.current_process);
      mConsole.log("Процесс <span class='proc_name'>" + processor.current_process.descriptor.FileName + "</span> <b>(" + processor.current_process.descriptor.pid + ")</b> помещен в очередь <b>ГОТОВЫХ</b> (" + processor.current_process.context.Command + ")");
      draw_process(processor.current_process);
      return this.clearProcessor();
    };

    return processor;

  })();

  io = (function() {
    function io() {}

    io.current_process;

    io.D = 1;

    io.CurrentStep = 0;

    io.CountSteps = 0;

    io.spooling = [];

    io.error = false;

    io.checkerror = function() {
      var iorange, rng;
      iorange = parseInt(document.getElementById("iorange").value);
      rng = Math.floor(Math.random() * 100);
      if (rng <= Math.floor(iorange)) {
        mConsole.log("Произошла <b style='color: #ff2749'>ошибка</b> <b>ввода/вывода</b>! Процесс <span class='proc_name'>" + io.current_process.descriptor.FileName + "</span> <b>(" + io.current_process.descriptor.pid + ")</b> аварийно завершен!");
        document.getElementById("spool_el" + io.current_process.descriptor.pid).style.backgroundColor = "#ff006a";
        this.error = true;
      }
    };

    io.process_error = function(p) {
      return console.log(p);
    };

    io.draw_spooling_process = function(p) {
      var doc_elem, text;
      text = generatePlainbyProcess(p);
      doc_elem = document.createElement("div");
      doc_elem.setAttribute('id', "spool_el" + p.descriptor.pid);
      doc_elem.classList.add("spooling_element");
      doc_elem.innerText = p.descriptor.pid;

      /*doc_elem.setAttribute('data-tippy-content', text) */
      document.getElementById("Spooling").appendChild(doc_elem);
      return tippy(doc_elem, {
        content: text,
        placement: 'top',
        allowHTML: true
      });
    };

    io.run_process = function(p) {
      if (io.D === 1) {
        io.current_process = p;
        io.CurrentStep = 0;
        io.CountSteps = p.context.CommandValue;
        io.D = 0;
        mConsole.log("Процесс <span class='proc_name'>" + p.descriptor.FileName + "</span> <b>(" + p.descriptor.pid + ")</b> обрабатывается в соответствии с очередью <i>спуллинга</i>");
      }

      /*else if (io.D is 0 ) #Если I/O Занят
        console.log "Ввод-Вывод занят. Ожидание"
       */
    };

    io.tick = function() {
      var ii, k, key, len, n, p, value;
      if (io.D === 0) {
        if (this.error) {
          mMemory.free(io.current_process);
          io.D = 1;
          io.CurrentStep = 0;
          io.CountSteps = 0;
          ii = this.spooling.indexOf(io.current_process);
          this.spooling.splice(ii, 1);
          document.getElementById("spool_el" + io.current_process.descriptor.pid).remove();
          io.current_process = null;
          switchTimer();
          this.error = false;
          return;
        }
        if (io.CountSteps > 0 && io.CurrentStep >= io.CountSteps) {
          io.D = 1;
          io.current_process.descriptor.State = process_states.Ready;
          io.current_process.context.CommandLine++;
          io.current_process.refreshCommand();
          io.CurrentStep = 0;
          io.CountSteps = 0;
          io.current_process.descriptor.State = process_states.Ready;
          ready_processes_stack.push(io.current_process);
          mConsole.log("Процесс <span class='proc_name'>" + io.current_process.descriptor.FileName + "</span> <b>(" + io.current_process.descriptor.pid + ")</b> освободил <b>i/o</b> и помещен в очередь <b>ГОТОВЫХ</b>");
          draw_process(io.current_process);
          mConsole.log("Устройство <b>ввода/вывода</b> свободно");
          ii = this.spooling.indexOf(io.current_process);
          this.spooling.splice(ii, 1);
          document.getElementById("spool_el" + io.current_process.descriptor.pid).remove();
          switchTimer();
          paintCat();
          ioRedraw();
        } else {
          io.CurrentStep++;
          this.checkerror();
        }
        ioRedraw();
        return;
      }
      if (io.D === 1) {
        if (this.spooling.length === 0) {
          console.log(waiting_processes_stack);
          waiting_processes_stack = waiting_processes_stack.filter(function(element) {
            if (element.descriptor.Waiting === "paint_cat") {
              return true;
            } else {
              return false;
            }
          });
          if (waiting_processes_stack.length > 0) {
            for (n in process_priors) {
              for (key = k = 0, len = waiting_processes_stack.length; k < len; key = ++k) {
                value = waiting_processes_stack[key];
                if (value.descriptor.priority === n) {
                  this.spooling.push(value);
                  p = value;
                  mConsole.log("Процесс <span class='proc_name'>" + p.descriptor.FileName + "</span> <b>(" + p.descriptor.pid + ")</b> попал в <i>спуллинг</i> устройства <b>Ввода/вывода</b>");
                  erase_process(value.descriptor.pid);
                  this.draw_spooling_process(value);
                  waiting_processes_stack.splice(key, 1);
                  break;
                }
              }
            }
          } else {
            debugger;
            mConsole.log("Устройство <b>ввода/вывода</b> свободно, процессов не обнаружено");
            switchTimer();
          }
        } else {
          if (this.spooling.length > 0) {
            io.run_process(this.spooling[0]);
          }
        }
      }
    };

    return io;

  })();

  processes_dispatcher = (function() {
    function processes_dispatcher() {}

    processes_dispatcher.new_process = function(processDescriptor) {
      var c_process, command, context, rnd;
      if (processDescriptor instanceof process_descriptor) {
        rnd = Math.floor(Math.random() * (10 - 1)) + 1;
        processDescriptor.quantum = rnd;
        processDescriptor.State = process_states.Ready;
        context = new process_context(processDescriptor.pid);
        c_process = new process(processDescriptor, context);
        command = c_process.descriptor.command_list[0];
        command = split_command(command);
        c_process.context.Command = command.command_type;
        c_process.context.CommandValue = command.command_value;
        mConsole.log("Запущен новый процесс <span class='proc_name'>" + c_process.descriptor.FileName + "</span> с приоритетом <span class='proc_quantum'>" + c_process.descriptor.priority + "</span>");
        mConsole.log("Процессу <span class='proc_name'>" + c_process.descriptor.FileName + "</span> случайным образом присовоен Квант <b>" + c_process.descriptor.quantum + "</b>");
        mConsole.log("Процессу <span class='proc_name'>" + c_process.descriptor.FileName + "</span> присовоен Идентификатор <b>" + c_process.descriptor.pid + "<b>");
        if (context.Command === "ПАМЯТЬ") {
          mMemory.use(c_process, c_process.context.CommandValue);
          c_process.context.CommandLine++;
          command = c_process.descriptor.command_list[c_process.context.CommandLine];
          command = split_command(command);
          c_process.context.Command = command.command_type;
          c_process.context.CommandValue = command.command_value;
        }
        ready_processes_stack.push(c_process);
        mConsole.log("Процесс <span class='proc_name'>" + c_process.descriptor.FileName + "</span> <b>(" + c_process.descriptor.pid + ")</b>  помещен в очередь <b>ГОТОВЫХ</b> (" + c_process.context.Command + ")");
        draw_process(c_process);
        return c_process;
      } else {
        throw "В очердь процессора добавлен не процесс!";
      }
    };

    processes_dispatcher.get_last_rdy_process = function(sliceInStack) {
      var k, key, len, n, value;
      for (n in process_priors) {
        for (key = k = 0, len = ready_processes_stack.length; k < len; key = ++k) {
          value = ready_processes_stack[key];
          if (value.descriptor.priority === n) {
            return value;
          }
        }
      }
    };

    processes_dispatcher.timer_tick = function() {
      var current_process, last_process, line_index;
      document.getElementById("processor_conext").innerText = "-";
      if (processor.TStateProcessor === TStateProcessor.Empty) {
        last_process = this.get_last_rdy_process(false);
        if (last_process) {
          processor.run(last_process);
          draw_process(last_process);
          mConsole.log("Процесс <span class='proc_name'>" + last_process.descriptor.FileName + "</span> <b>(" + last_process.descriptor.pid + ")</b> переведен в состояние <b>Выполнение</b> (" + last_process.context.Command + ")");
        }
      } else {
        if (processor.TStateProcessor === TStateProcessor.Busy) {
          if (processor.current_process != null) {
            current_process = processor.current_process;
            line_index = current_process.context.CommandLine;
            if (line_index >= current_process.descriptor.command_list.length) {
              processor.TStateProcessor = TStateProcessor.Empty;
              mMemory.free(processor.current_process);
              erase_process(processor.current_process.descriptor.pid);
              mConsole.log("Процесс <span class='proc_name'>" + current_process.descriptor.FileName + "</span> <b>(" + current_process.descriptor.pid + ")</b> <span class='finished'>Завершен</span>");
              delete processor.current_process;
              processor.finishCurProc();
              return;
            }
            switch (current_process.context.Command) {
              case "ПАМЯТЬ":
                if (Number.isInteger(current_process.context.CommandValue)) {
                  mMemory.use(current_process, current_process.context.CommandValue);
                  current_process.context.CommandLine++;
                  current_process.refreshCommand();
                  processor.moveProcessToReady();
                } else {
                  alert("Недостаточно памяти!!!!");
                  processor.moveProcessToReady();
                }
                break;
              case "ПРОЦЕССОР":
                if (current_process.context.CurrentRun >= current_process.context.CommandValue) {
                  current_process.context.CurrentRun = 0;
                  current_process.context.CommandLine++;
                  document.getElementById("processor_conext").innerText = "-";
                  current_process.refreshCommand();
                  processor.moveProcessToReady();
                } else {
                  document.getElementById("processor_conext").innerText = current_process.context.CurrentRun + " из " + current_process.context.CommandValue;
                  current_process.context.CurrentRun = current_process.context.CurrentRun + current_process.descriptor.quantum;
                  if (current_process.context.CurrentRun >= current_process.context.CommandValue) {
                    current_process.context.CurrentRun = current_process.context.CommandValue;
                  }
                  redraw_process(current_process);
                }
                break;
              case "ВВОД\\ВЫВОД":
                mConsole.log("Процесс <span class='proc_name'>" + current_process.descriptor.FileName + "</span> <b>(" + current_process.descriptor.pid + ")</b> переведен в состояние <b>Ожидание</b> (" + current_process.context.Command + ")");
                current_process.descriptor.State = process_states.Wait;
                current_process.descriptor.Waiting = "paint_cat";
                waiting_processes_stack.push(current_process);
                console.log(waiting_processes_stack);
                processor.clearProcessor();
                draw_process(current_process);

                /*io.run(current_process) */
                switchTimer();
                break;
              case "КОНЕЦ":
                current_process.context.CommandLine++;
                current_process.refreshCommand();
                current_process.descriptor.State = process_states.Finish;
                break;
              default:
                alert("неизвестная команда процессора");
            }
            if (processor.current_process != null) {
              redraw_process(processor.current_process);
            }
          }
        }
      }
    };

    return processes_dispatcher;

  })();

  split_command = function(inCommand) {
    var command, command_type, value;
    command = inCommand.split('-');
    command_type = command[0].toUpperCase();
    value = parseInt(command[1]);
    if (Number(value) === value && value % 1 === 0) {
      return {
        command_type: command_type,
        command_value: value
      };
    } else {
      return {
        command_type: command_type,
        command_value: null
      };
    }
  };

  paintCat = function() {
    var input, rnd, t;
    input = document.getElementById("inputoutput_device");
    t = document.createElement('img');
    rnd = Math.floor(Math.random() * (img_cats.length - 1)) + 1;
    if (!rnd) {
      alert("ERRRRRRRRRROR");
    }
    t.src = "img/cats/" + img_cats[rnd];
    t.classList.add('cat');
    t.classList.add('cat_fly');
    input.prepend(t);
    return setTimeout((function(_this) {
      return function() {
        return t.remove();
      };
    })(this), 3000);
  };

  erase_process = function(pid) {
    var element;
    element = document.querySelector("div[data-processid=\"" + pid + "\"]");
    element.classList.add('hide');
    return window.setTimeout((function() {
      return element != null ? element.remove() : void 0;
    }), 350);
  };

  redraw_process = function(in_process) {
    var element, text;
    element = document.querySelector("div[data-processid=\"" + in_process.descriptor.pid + "\"] ");
    text = generateHTMLbyProcess(in_process);
    if (in_process.descriptor.State === process_states.Finish) {
      element.classList.add('finished');
    }
    return element.innerHTML = text;
  };

  draw_process = function(in_process) {
    var columnId, oldestElement, t, text;
    switch (in_process.descriptor.State) {
      case process_states.Ready:
        columnId = "ready_column";
        break;
      case process_states.Run:
        columnId = "runing_column";
        break;
      case process_states.Wait:
        columnId = "waiting_column";
        break;
      default:
        columnId = null;
    }
    if (columnId) {
      oldestElement = document.querySelector("div[data-processid=\"" + in_process.descriptor.pid + "\"]");
      if (oldestElement) {
        oldestElement.classList.add('hide-to-left', 'hide');
        window.setTimeout((function() {
          return oldestElement != null ? oldestElement.remove() : void 0;
        }), 350);
      }
      text = generateHTMLbyProcess(in_process);
      t = document.createElement('div');
      t.setAttribute('data-processid', in_process.descriptor.pid);
      t.className = "view_process";
      t.innerHTML = text;
      return document.getElementById(columnId).appendChild(t);
    }
  };

  generateHTMLbyProcess = function(process) {
    var context_text, descriptor_text, key, ref, ref1, text, value;
    context_text = "";
    descriptor_text = "";
    ref = process.context;
    for (key in ref) {
      value = ref[key];
      value = (value != null) ? value.toString() : "none";
      context_text += (key.toString()) + " : " + (value.toString()) + "<br/>";
    }
    if (process.context.Command === process_comands.PROCESSOR && (process.context.CommandValue != null) && (process.context.CurrentRun != null)) {
      context_text += "<progress max=\"" + process.context.CommandValue + "\" value=\"" + process.context.CurrentRun + "\"></progress>";
    }
    ref1 = process.descriptor;
    for (key in ref1) {
      value = ref1[key];
      if (key === 'command_list') {
        continue;
      }
      value = (value != null) ? value.toString() : "none";
      descriptor_text += "<div>" + (key.toString()) + " : " + (value.toString()) + "</div>";
    }
    text = descriptor_text + ("<div class='context'>Контекст: <div>" + context_text + "</div></div>");
    return text;
  };

  generatePlainbyProcess = function(process) {
    var context_text, descriptor_text, key, ref, ref1, text, value;
    context_text = "Контекст:<br/>";
    descriptor_text = "Дескриптор:<br/>";
    ref = process.context;
    for (key in ref) {
      value = ref[key];
      value = (value != null) ? value.toString() : "none";
      context_text += (key.toString()) + " : " + (value.toString()) + " | ";
    }
    ref1 = process.descriptor;
    for (key in ref1) {
      value = ref1[key];
      if (key === 'command_list') {
        continue;
      }
      value = (value != null) ? value.toString() : "none";
      descriptor_text += (key.toString()) + " : " + (value.toString()) + " | ";
    }
    text = descriptor_text + "<br/>" + context_text;
    return text;
  };

  ioRedraw = function() {
    var status;
    if (io.D === 1) {
      status = "Свободно";
      document.getElementById("inputoutput_device_process").innerText = "-";
      document.getElementById("inputoutput_device_name").innerText = "-";
      document.getElementById("inputoutput_device_pid").innerText = "-";
    } else {
      status = "Работает";
      document.getElementById("inputoutput_device_process").innerText = io.CurrentStep + " из " + io.CountSteps;
      document.getElementById("inputoutput_device_name").innerText = io.current_process.descriptor.FileName;
      document.getElementById("inputoutput_device_pid").innerText = io.current_process.descriptor.pid;
    }
    document.getElementById("inputoutput_device_state").innerText = status;
  };

  generateSelectTags = function() {
    var key, process_priors_select_text, val;
    process_priors_select_text = "<select name=\"process_prior\">";
    for (key in process_priors) {
      val = process_priors[key];
      process_priors_select_text += "<option value=\"" + key + "\">" + val + "</option>";
    }
    process_priors_select_text += "</select>";
    return process_priors_select_text;
  };

  openTab = function(evt, dataname) {
    var i, j, k, l, len, len1, len2, m, n, processes, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("process");
    for (k = 0, len = tabcontent.length; k < len; k++) {
      i = tabcontent[k];
      i.style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (l = 0, len1 = tablinks.length; l < len1; l++) {
      j = tablinks[l];
      j.className = j.className.replace(" active", "");
    }
    processes = document.querySelectorAll(".process[data-processname=\"" + dataname + "\"]");
    for (m = 0, len2 = processes.length; m < len2; m++) {
      n = processes[m];
      n.style.display = "flex";
    }
    evt.currentTarget.className += " active";
  };

  createProcessTab = function(f) {
    var b, btn, btns, btnsWrap, k, len, processinfo, reader, runButton, selecttags, table, tableW, tableWrap, tablesWrap;
    tablesWrap = document.getElementById("prcoessTextFromFileTabs");
    tableW = tablesWrap.querySelector(".process[data-processname=\"" + f.name + "\"]");
    if (tableW == null) {
      tableWrap = document.createElement("div");
      table = document.createElement("table");
      processinfo = document.createElement("div");
      runButton = document.createElement("button");
      tableWrap.setAttribute("data-processname", f.name);
      tableWrap.className = "process";
      tablesWrap.appendChild(tableWrap);
      tableWrap.appendChild(table);
      runButton.className = "runProcessButton";
      runButton.innerText = "Добавить процесс в очередь";
      runButton.addEventListener("click", function(e) {
        var commandList, commandListTD, pr, processDescriptor, process_name, select, select_value;
        select = e.target.parentElement.querySelector("select[name=\"process_prior\"]");
        process_name = e.target.parentElement.parentElement.getAttribute('data-processname');
        select_value = select.value;

        /*определяем лист команд */
        commandListTD = Array.from(document.getElementById("prcoessTextFromFileTabs").querySelectorAll("div[data-processname=\"" + process_name + "\"] table tbody tr td"));
        commandList = commandListTD.map(function(item) {
          return item.innerText;
        });
        processDescriptor = new process_descriptor(null, 1, "None", select_value, commandList, f.name);
        pr = processes_dispatcher.new_process(processDescriptor);
        return this;
      });
      btnsWrap = document.getElementById("processesTabsBtns");
      btn = document.createElement("button");
      btn.className = "tablinks";
      btn.innerText = f.name;
      btn.addEventListener("click", function(e) {
        return openTab(e, f.name);
      });
      btnsWrap.appendChild(btn);
      selecttags = generateSelectTags();
      processinfo.innerHTML = "<div >Приоритет: " + selecttags + "</div>";
      processinfo.appendChild(runButton);
      tableWrap.appendChild(processinfo);
    } else {
      table = tableW.getElementsByTagName("table");
      btns = document.querySelectorAll(".tab .tablinks");
      for (k = 0, len = btns.length; k < len; k++) {
        b = btns[k];
        if (b.textContent.includes(f.name)) {
          btn = b;
          break;
        }
      }
    }
    openTab({
      currentTarget: btn
    }, f.name);
    reader = new FileReader();
    reader.onload = function(theFile) {
      var cell1, contents, l, lines, results, row, s;
      contents = theFile.currentTarget.result;
      lines = contents.split('\n');
      results = [];
      for (l = lines.length - 1; l >= 0; l += -1) {
        s = lines[l];
        s = s.trim();
        if ((s != null) && s.length > 0) {
          row = table.insertRow(0);
          cell1 = row.insertCell(0);
          results.push(cell1.innerHTML = s);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    return reader.readAsText(f, "CP1251");
  };

  handleFileSelect = function(evt) {
    var f, files, k, len;
    files = evt.target.files;
    if (Array.isArray(files)) {
      for (k = 0, len = files.length; k < len; k++) {
        f = files[k];
        createProcessTab(f);
        mConsole.log("Процесс <span class='proc_name'>" + f.name + "</span> инициализирован!");
      }
    } else {
      createProcessTab(files[0]);
      mConsole.log("Процесс <span class='proc_name'>" + files[0].name + "</span> инициализирован!");
    }
  };

  window.onload = function() {
    var consoleFullSizeBtn, fileInput;
    fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', handleFileSelect, false);
    mMemory.refresh();
    mConsole.log("Модель процессора подготовлена");
    mConsole.log("Модель устройства ввода/вывода подготовлена");
    consoleFullSizeBtn = document.querySelector('#console_wrap>button');
    return consoleFullSizeBtn.addEventListener("click", function() {
      var wrap;
      wrap = document.getElementById("console_wrap");
      if (wrap.classList.contains("full-sized")) {
        wrap.classList.remove("full-sized");
      } else {
        wrap.classList.add("full-sized");
      }
    });
  };

  ioTimer = {};

  processTimer = {};

  processTimerRunned = false;

  lastStartedTimer = null;

  processorStartButton = document.getElementById('processor_start');

  tick = 0;

  timerRunned = false;

  switchTimer = (function(_this) {
    return function() {
      if (lastStartedTimer === processTimer) {
        processTimer.stop();
        lastStartedTimer = ioTimer;
        return ioTimer.run();
      } else {
        ioTimer.stop();
        lastStartedTimer = processTimer;
        return processTimer.run();
      }
    };
  })(this);

  processTimer = (function() {
    function processTimer() {}

    processTimer.running = false;

    processTimer.interval = {};

    processTimer.wrap = document.getElementById("processor");

    processTimer.run = function() {
      this.interval = setInterval((function() {
        var progressbar;
        progressbar = document.getElementById("tick_progress");
        if (progressbar.value === 2000) {
          progressbar.value = 0;
          tick++;
          processes_dispatcher.timer_tick();
        } else {
          progressbar.value = progressbar.value + 20;
        }
      }), 5);
      this.running = true;
      return this.wrap.classList.remove('disabled');
    };

    processTimer.stop = function() {
      clearInterval(this.interval);
      this.running = false;
      return this.wrap.classList.add('disabled');
    };

    return processTimer;

  })();

  ioTimer = (function(superClass) {
    extend(ioTimer, superClass);

    function ioTimer() {
      return ioTimer.__super__.constructor.apply(this, arguments);
    }

    ioTimer.wrap = document.getElementById("io_wrap");

    ioTimer.run = function() {
      this.interval = setInterval((function() {
        var progressbar;
        progressbar = document.getElementById("tick_progress_io");
        if (progressbar.value === progressbar.max) {
          progressbar.value = 0;
          tick++;
          io.tick();
        } else {

        }
        progressbar.value = progressbar.value + 50;
      }), 6);
      this.running = true;
      return this.wrap.classList.remove('disabled');
    };

    return ioTimer;

  })(processTimer);

  processorStartButton.addEventListener("click", function(e) {
    if (!timerRunned) {
      if (!lastStartedTimer) {
        lastStartedTimer = processTimer;
      }
      timerRunned = true;
      e.target.innerHTML = "Остановить планировщик";
      lastStartedTimer.run();
    } else {
      timerRunned = false;
      lastStartedTimer.stop();
      e.target.innerHTML = "Запустить планировщик";
    }
  });

  iorange = document.getElementById('iorange');

  listener = function() {
    window.requestAnimationFrame(function() {
      document.getElementById('range-val').innerHTML = iorange.value + "%";
    });
  };

  iorange.addEventListener('mousedown', function() {
    listener();
    iorange.addEventListener('mousemove', listener);
  });

  iorange.addEventListener('mouseup', function() {
    iorange.removeEventListener('mousemove', listener);
  });

  iorange.addEventListener('keydown', listener);

}).call(this);

//# sourceMappingURL=js.js.map
